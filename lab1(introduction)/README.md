# Лабораторная работа №1
В раммках первого занятия вам предстоит познакомится с системой контроля версий **Git**, с которой мы будем работать на протяжении семестра.
## Git

Практически каждый современный проект использует системы версионного контроля. Git — самый популярный инструмент для контроля версий. Здесь не будет подробного гайда по использованию этой платформы, т.к. самый верный способ обучиться владению Git — испытать его своими руками. Оставлю несколько ресурсов, в которых подробно расписаны первые шаги, а также настройка Git:
- [Version Control with Git](https://learn.epam.com/catalog/detailsPage?id=601f195a-d408-4439-a16d-0630ed2a412e) — курс от EPAM, в котором собраны основные концепции работы с платформой(**обращаю внимание**, что для доступа к курсу необходимо быть зарегистрированным на сайте).
- [GitHowTo](https://githowto.com/ru) — сайт("интерактивный учебник"), знакомящий вас с основами Git.

В рамках предмета мы будем работать с одним репозиторием [cpp_labs](). Каждый студент создаст копию этого репозитория на своём аккаунте (так назыавемый **fork**), с которым он будет работать и загружать результаты своей проделанной работы. Подробнее как это сделать будет разобрано на занятии.

### Клонирование репозитория

Вы сделали ответвление основного репозитория себе на аккаунт. Для начала работы с этим репозиторием нужно клонировать его локальную копию себе на компьютер:
```
git clone "ссылка на ваш репозиторий"
```

### Создание веток
После клонирования репозитория вы увидите в нём только одну ветку (она называется  **main**), с которой вы будете продолжать работать на протяжении всего семестра. Обычно изменения в эту ветку загружаются на самой последней стадии разработки (после ревью кода, тестирования и т.п.). В нашем же случае вы можете работать напрямую с веткой main, но я рекомендую сразу учиться делать хорошо, чтобы потом не переучиваться.

> Стоит отметить, что ещё в репозитоии помимо ветки main есть ещё так называемая ветка **dev**. Она служит в качестве "интеграционной" ветки, где собираются изменения из различных веток разработки (их обычно назвают **feature-ветки**) перед тем, как они будут объединены в основную ветку main (или master). Мы же с вами во время обучения будем работать напрямую с веткой main. 
 
Обычно для каждой новой задачи создаётся своя feature-ветка с характерным для этого названием (например feature1_add_logic, featue_solve_task1 и т.п), в которой работают только над одной конктретной задачей. Создать ветку можно, например, с помощью следующей команды:

```
git checkout -b "название_ветви"
```
При создании ветви командой выше, вы автоматически на неё перейдете. Но настоятельно рекомендую проверить, на какой ветви вы находитесь Это можно сделать с помощью команды **git status**. Если же вы по какой-то причине не перешли на свою ветвь, то это можно сделать, например, с помощью следующей команды:
```
git switch "название ветви"
``` 

После чего можно приступать к работе в этой ветке. После окончания работы с этой веткой её обычно сливают с какой-то из основных (в нашем случае это ветка main), а саму ветку удаляют.

## Первая программа на C++
После того, как вы клонировали репозиторий и создали свою ветвь для работы, перейдём к первой программе, так называемой $Hello, world$ на языке программирования C++:
```cpp
#include <iostream>

int main() {
    std::cout << "Hello, world!" << std::endl;
    return 0;
}
```
Разберём эту программу подробнее:
- В строке `#include <iostream>` мы подключаем библиотеку `iostream`, которая предназначена для работы с вводом и выводом данных в поток / из потока.
- `int main()` объявляет фнукцию `main`, с которой **всегда** начинается выполнение программы. Эта функция должна вернуть целое число(int).
- `std::cout << "Hello, world!" << std::endl;` — здесь мы
выводим строку $"Hello, world!"$ на консоль, используя специальный объект `std::cout` и оператор `<<`. `std::endl` переводит курсор на новую строку.
- `return 0` — возвращает из функции `main' число 0 (так называемый код завершения программы). Если программа завершается с кодом 0, то это обычно означает успешное завершение программы.

### Замечания
1. `std::endl` в данном случае можно и не использовать, указав вместо этого специальный символ в строке $Hello, world!$, также означающий переход на новую строку — `\n`. Получаем следующую программу:
```cpp
#include <iostream>

int main() {
    std::cout << "Hello, world!\n";
    return 0;
}
```
2. Зависимое имя `std::cout` означает, что мы используем объект `cout` из пространства имён `std`. Префикс `std::` можно не писать, указав, что мы добавим **все** имена из пространства имён `std` с помощью директивы `using`:
```cpp
#include <iostream>

using namespace std;

int main() {
    cout << "Hello, world!\n";
    return 0;
}
```
3. Используемый в пункте 2 метод не рекомендуется, т.к. могут возникнуть конфликты имён, из-за которых очень часто программа может работать неправильно или вообще не работать (например, в пространстве имён `std` есть функция `left` и у вас в программе будет переменная с именем `left`), и иногда бывает очень трудно найти ошибку в коде или понять, из-за чего программа не компилируется. Вместо этого я рекомендую использовать директиву `using` в "максимально узкой области видимости" (в нашем случае внести её в функцию `main` в немного другой форме). В таком случае будет гораздо легче найти ошибку, если что-то пойдёт не так:
```cpp
#include <iostream>

int main() {
    using std::cout; // будем использовать cout из std
    cout << "Hello, world!\n";
    return 0;
}
```

## Задания к лабоработной работе №1
- В текущей директории (в папке first_class) создать файл **main.cpp**, в который скопировать первую программу $Hello, world!$. Попробовать скомпилировать эту программу, выполнить её.
- В этой же директории в файле **lab1_introduction.pdf** находятся задания к первой лабораторной работе. Из этих заданий (кроме 1 и 12) сделать 5 на выбор. Задание 1 мы разобрали на занятии, задание №12 "со звёздочкой" — подумайте, как его можно сделать.
- Добавить файл **main.cpp** и файл(ы) с решением лабораторной работы в вашу ветку. Это можно сделать, например, так:
    1. добавляем все изменения перед созданием коммита
        ```
        git add *
        ```
    2. сам коммит:
        ```
        git commit -m "Что изменилось/добавилось"
        ```
    3. загружаем эти изменения в вашей ветке из вашего локального репозитория на удаленный (в нашем случае на Git):
        ```
        git push origin "название_ветки"
        ```
    4. сливаем нашу ветку с основной веткой main(это можно сделать прямо на сайте github или же с помощью команды git merge):
        ```
        git checkout main
        git merge "название ветки, которую хотим слить с main"
        ```